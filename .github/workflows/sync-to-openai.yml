name: Sync Repo to OpenAI Storage (per-file, robust paths)

on:
  workflow_call:
    inputs:
      vector_store_id:
        required: true
        type: string
    secrets:
      OPENAI_API_KEY:
        required: true

concurrency:
  group: sync-openai-${{ github.repository }}
  cancel-in-progress: true

jobs:
  sync-repo:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: npm i openai@^4

      - name: Upload files one by one (dedupe + skip unchanged)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          VECTOR_STORE_ID: ${{ inputs.vector_store_id }}
        run: |
          node --input-type=module - <<'NODE'
          import fs from "fs";
          import path from "path";
          import crypto from "crypto";
          import { execSync } from "child_process";
          import OpenAI from "openai";

          const apiKey   = process.env.OPENAI_API_KEY;
          const vsId     = process.env.VECTOR_STORE_ID;
          const repoName = (process.env.GITHUB_REPOSITORY || "").split("/").pop();

          if (!apiKey) throw new Error("Missing OPENAI_API_KEY");
          if (!vsId)   throw new Error("Missing VECTOR_STORE_ID");

          const client = new OpenAI({ apiKey });

          // files/dirs to ignore
          const IGNORE_DIRS = [
            ".git/",
            ".github/workflows/",
            "node_modules/",
            ".gitbook/assets/"
          ];

          // binary extensions we won't upload
          const BIN_EXT = /\.(png|jpg|jpeg|gif|svg|ico|pdf|zip|gz|tgz|bz2|xz|7z|rar|mp3|mp4|mov|avi|mkv|webm|wav|ogg|flac|lock|woff2?|ttf|eot|exe|dll|so|dylib|psd|ai|sketch)$/i;

          // Null-separated listing; safe for spaces/newlines/quotes in names
          function listFiles() {
            const raw = execSync("git ls-files -z", { encoding: "buffer" });
            return raw
              .toString("utf8")
              .split("\0")
              .filter(Boolean)
              .map((f) => f.replace(/^"(.*)"$/, "$1")) // strip accidental surrounding quotes
              .filter((f) => !IGNORE_DIRS.some((d) => f.startsWith(d)))
              .filter((f) => !BIN_EXT.test(f));
          }

          const sha256 = (p) =>
            crypto.createHash("sha256").update(fs.readFileSync(p)).digest("hex");

          // paginate whole vector store
          async function* pages(params = {}) {
            let after;
            do {
              const res = await client.vectorStores.files.list(vsId, { after, limit: 100, ...params });
              yield res;
              after = res?.last_id;
            } while (after);
          }

          async function getAllByFilename(name) {
            const matches = [];
            for await (const page of pages()) {
              for (const f of page.data) if (f.filename === name) matches.push(f);
            }
            return matches;
          }

          async function deleteAllByFilename(name) {
            const all = await getAllByFilename(name);
            for (const f of all) {
              try {
                await client.vectorStores.files.del(vsId, f.id);
                console.log("Deleted old copy:", f.id, f.filename);
              } catch (e) {
                console.warn("Failed to delete", f.id, e?.response?.data || e?.message || e);
              }
            }
          }

          async function hasSameHash(name, sha) {
            for await (const page of pages()) {
              for (const f of page.data) {
                if (f.filename === name && f.attributes && f.attributes.sha256 === sha) {
                  return true;
                }
              }
            }
            return false;
          }

          const files = listFiles();
          console.log(`Found ${files.length} candidate files`);

          (async () => {
            for (const rel of files) {
              // sanitize any stray quotes again before FS ops
              const cleanRel = rel.replace(/^"(.*)"$/, "$1");
              const abs = path.resolve(cleanRel);

              if (!fs.existsSync(abs)) {
                console.log(`Skipping (missing): ${cleanRel}`);
                continue;
              }

              let st;
              try {
                st = fs.statSync(abs);
              } catch (e) {
                console.log(`Skipping (stat error): ${cleanRel} -> ${e.message}`);
                continue;
              }

              if (!st.isFile()) {
                console.log(`Skipping (not a file): ${cleanRel}`);
                continue;
              }
              if (st.size > 2 * 1024 * 1024) {
                console.log(`Skipping (too large >2MB): ${cleanRel}`);
                continue;
              }
              if (BIN_EXT.test(cleanRel)) {
                console.log(`Skipping (binary ext): ${cleanRel}`);
                continue;
              }

              const filename = `${repoName}/${cleanRel}`;
              const hash = sha256(abs);

              if (await hasSameHash(filename, hash)) {
                console.log(`Unchanged, skipping: ${filename}`);
                continue;
              }

              await deleteAllByFilename(filename);

              try {
                let vf;
                if (typeof client.vectorStores?.files?.uploadAndPoll === "function") {
                  vf = await client.vectorStores.files.uploadAndPoll(
                    vsId,
                    fs.createReadStream(abs),
                    { filename, attributes: { repo: repoName, path: cleanRel, sha256: hash } }
                  );
                } else {
                  const created = await client.files.create({
                    file: fs.createReadStream(abs),
                    purpose: "assistants",
                    filename
                  });
                  vf = await client.vectorStores.files.createAndPoll(vsId, { file_id: created.id });
                }

                if (vf.status !== "completed") {
                  console.error("Index failed:", filename, vf?.last_error || vf?.status);
                } else {
                  console.log("Indexed:", filename);
                }
              } catch (err) {
                const body = err?.response?.data || err?.stack || err?.message || err;
                console.error(`‚ùå Failed ${filename}:`, body);
              }
            }
          })();
          NODE
